@2025-11-19
HIBERNATE (JAVA FRAMEWORK)
Hibernate I

Para aplicar el uso de Hibernate, se requiere:

	* Un constructor vacío (obligatorio para que Hibernate pueda instanciar objetos).
	* La anotación @Entity para indicar que la clase es una tabla.
	* La anotación @Id para indicar la clave primaria.

Opcionalmente también se usan con frecuencia:

	* @Table para personalizar el nombre de la tabla.
	* @Column para configurar columnas.
	* @GeneratedValue para autoincrementar la clave primaria.

Las librerías deben estar actualizadas con el proyecto.

La mayor ventaja de Hibernate es que permite trabajar con objetos Java en lugar de SQL, 
y además genera automáticamente el SQL apropiado para cualquier base de datos, por lo 
que es independiente del motor (MySQL, Oracle, PostgreSQL, etc.).
Igual que Maven usa el fichero pom.xml, Hibernate utiliza el fichero de configuración:
hibernate.cfg.xml. Para configurar:

	* conexión a la base de datos
	* usuario y contraseña
	* dialecto SQL a utilizar
	* entidades mapeadas
	* opciones de hbm2ddl

Ejemplo de conexión de Hibernate:
		public static Session connect() {
			Session session = null;
	        try {
				SessionFactory sessionFactory = new Configuration()
		                .configure() // Carga hibernate.cfg.xml
		                .buildSessionFactory();
				
		        session = sessionFactory.openSession();
		        System.out.println(session);
		        
			} catch (Throwable e) {
		        System.err.println("Error al crear la SessionFactory." + e);
		        throw new ExceptionInInitializerError(e);
		    }
	        return session;
		}

@2025-11-20
Hibernate II

Hibernate traduce automáticamente las clases Java a tablas en la base de datos elegida 
(ORM: Object–Relational Mapping). La propiedad hibernate.hbm2ddl.auto controla qué hace 
Hibernate con las tablas. Valores más usados:

	* create -> crea las tablas cada vez (borra las anteriores).
	* update -> actualiza las tablas sin borrarlas.
	* create-drop -> crea las tablas y las elimina al cerrar la sesión.
	* validate -> verifica que las tablas existen, pero no modifica nada.

El valor habitual en desarrollo es: update.
En producción normalmente se usa: validate o nada.

Para hacer una consulta (en HQL):

	* Se crea una lista del tipo objeto elegido
	* Es de session.createQuery(from <nombre de tabla>, Entity.class).list

@2025-11-25
Hibernate III

Si ocurre un error dentro de una transacción, se ejecuta rollback, que revierte todas 
las operaciones realizadas dentro de esa transacción. Esto mantiene la consistencia y 
evita resultados parciales. Reglas importantes del rollback:

	* Solo afecta a lo que ocurre dentro de la transacción actual.
	* Después de un rollback, la sesión puede quedar inválida, por lo que normalmente 
	se cierra y se abre otra.
	* Un commit hace permanentes todos los cambios.
	* Si se lanza una excepción de SQL o Hibernate, es obligatorio hacer rollback.

Uso típico:
	Transaction tx = session.beginTransaction();
	
	try {
	    // operaciones
	    tx.commit();
	} catch (Exception e) {
	    tx.rollback(); // deshacer cambios
	}

DAO (DATA ACCESS OBJECT) PATTERN
El patrón DAO separa la lógica de acceso a datos de la lógica de negocio.
Cada entidad tiene su propia clase DAO que maneja las operaciones CRUD (Create, Read, Update, Delete).

SINGLETON
El patrón Singleton asegura que una clase tenga solo una instancia y proporciona un punto de acceso 
global a ella. Se implementa con:
public class MiSingleton {
    private static MiSingleton instancia;

    private MiSingleton() {
        // constructor privado
    }

    public static MiSingleton getInstancia() {
        if (instancia == null) {
            instancia = new MiSingleton();
        }
        return instancia;
    }
}
Esto es útil para gestionar recursos compartidos, como conexiones a bases de datos.

@2025-11-26
Hibernate IV

	* @Id y @Entity son anotaciones esenciales en Hibernate para mapear clases Java a tablas de bases de datos.
	* @Entity indica que una clase es una entidad persistente y se mapea a una tabla en la base de datos.
	* @GeneratedValue(strategy = GenerationType.IDENTITY) se usa junto con @Id para indicar que el valor de 
		la clave primaria se genera automáticamente por la base de datos.
	* @Table(name = "nombre_tabla") permite personalizar el nombre de la tabla en la base de datos.
	* @Column(name = "nombre_columna", nullable = false, length = 100) permite personalizar 
	el nombre de la columna.
		** nullable = false indica que la columna no puede ser nula.
		** length = 100 establece la longitud máxima para campos de tipo String.
	* @Size(min = 2, max = 50) es una anotación de validación que asegura que el tamaño.
    del campo esté entre 2 y 50 caracteres.
	* @NotNull asegura que el campo no sea nulo.
	* @SequenceGenerator se usa para definir una secuencia personalizada para la generación de claves primarias.
	* @Email valida que el campo tenga un formato de correo electrónico válido.
	* @Pattern(regexp = "expresión_regular") valida que el campo coincida con la expresión regular dada.
	* @Min(0) y @Max(100) validan que un valor numérico esté dentro de los límites especificados.
	* @Temporal(TemporalType.DATE) se usa para mapear campos de tipo Date y especificar
    cómo se almacenan en la base de datos (DATE, TIME, TIMESTAMP).
    * @Lob se usa para mapear campos que almacenan grandes objetos, como textos largos o imágenes.

Ejemplo de uso combinado:
	@Entity
	@Table(name = "usuarios")
	public class Usuario {
	    @Id
	    @GeneratedValue(strategy = GenerationType.IDENTITY)
	    private Long id;
	
	    @Column(name = "nombre", nullable = false, length = 50)
	    @Size(min = 2, max = 50)
	    private String nombre;
	
	    @Column(name = "email", nullable = false, unique = true)
	    @NotNull
	    @Email
	    private String email;
	
	    @Column(name = "fecha_registro")
	    @Temporal(TemporalType.DATE)
	    private LocalDateTime fechaRegistro;
	
	    //Constructor vacío, getters y setters
	}
Estas anotaciones ayudan a definir la estructura de la base de datos y a validar los datos

@2025-12-01
Hibernate V

DTO (DATA TRANSPORT OBJECT) PATTERN
El patrón DTO se utiliza para transferir datos entre diferentes capas de una aplicación.
	* Una capa puede ser la capa de persistencia (DAO) y otra la capa de servicio o presentación.
Un DTO es una clase simple que contiene atributos y sus getters/setters, sin lógica de negocio.
Se crea un DTO para cada entidad que se desea transferir.

Paquetes comunes en una aplicación con Hibernate:
	* Paquete DAO
	* Paquete DTO
	* Paquete ENTITIES
	* Paquete SERVICE
	
@2025-12-03
Hibernate VI

CICLO DE VIDA DE UNA ENTIDAD EN HIBERNATE
1. Transient (Transitorio): La entidad se crea con el operador 'new' y no está asociada a ninguna 
sesión de Hibernate. No tiene representación en la base de datos.
2. Persistent (Persistente): La entidad está asociada a una sesión de Hibernate. Puede ser guardada, 
actualizada o eliminada en la base de datos.
3. Detached (Desacoplado): La entidad estuvo asociada a una sesión de Hibernate, pero esa sesión 
se cerró. La entidad ya no está gestionada por Hibernate.
4. Removed (Eliminado): La entidad está marcada para ser eliminada de la base de datos en la próxima 
sincronización con la base de datos (commit).

La anotación @OneToMany se utiliza para definir una relación uno a muchos entre dos entidades.
Por ejemplo, una entidad "Autor" puede tener muchos "Libros". La anotación se coloca en la
entidad que tiene la colección (en este caso, "Autor") y se especifica el atributo "mappedBy"
para indicar el campo que posee la relación en la entidad "Libro".

La anotacion @OneToOne se utiliza para definir una relación uno a uno entre dos entidades.
Por ejemplo, una entidad "Persona" puede tener un "Pasaporte". La anotación se coloca en
la entidad que posee la relación y se puede usar junto con @JoinColumn para especificar
la columna de unión en la base de datos.

Tipos de carga de relaciones en Hibernate:
	* Eager: Carga inmediata de la relación al cargar la entidad principal.
	* Lazy: Carga diferida de la relación, solo se carga cuando se accede a ella.
